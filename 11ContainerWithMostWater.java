public class Solution {
    public int maxArea(int[] height) {

        int p1 = 0, p2 = height.length - 1;
        int maxArea = (height.length - 1) * Math.min(height[p1], height[p2]);


        while(p1 < p2) {
            maxArea = Math.max(maxArea, (p2-p1) * Math.min(height[p1], height[p2]));
            if(height[p1+1] > height[p2-1]) {
                p1++;
            } else {
                p2--;
            }
        }
        return maxArea;
    }

// 想法：
// 更大的底长和更大的高；
// 反正两侧的指针都是要向里移动的，要么移动左边，要么移动右边，底长一定会减小
// 那为了得到更大的面积(或者至少面积不要减少)，我们要让想办法得到更高的高，也就是想办法让短的那根柱子变长
// 如果移动现在更长的那根柱子，那么分两种情况，新的柱子要么比旧的更矮的柱子矮，要么比更矮的柱子高
// 所以如果移动现在更长的那根柱子，新的高要么是旧的高，要么是更矮的高，也就是新的那根柱子的长度；因此面积只能更小
// 那要是移动现在更矮的柱子的话，新的柱子要么比旧的高更高，要么比旧的高更矮
// 所以如果移动现在更矮的柱子的话，那么面积要么变大，要么变小，还是有可能变大的！！！
// 我们要维护的是最大面积，只要我们逼近面积有可能长大的方向，那么到最后，最大面积是一定会经历的，只要经历了我们就可以保存他了！

}
